
declare class GPXAnalytics extends NSObject {

	static alloc(): GPXAnalytics; // inherited from NSObject

	static debug(showDebugLogs: boolean): void;

	static new(): GPXAnalytics; // inherited from NSObject

	static sharedAnalytics(): GPXAnalytics;

	constructor(o: { configuration: any; });

	configurations(): any;

	disable(): void;

	enable(): void;

	flush(): void;

	getAptrinsicId(): string;

	identifyUserAccountOptionsEventTypeSessionId(userId: string, userData: NSDictionary<any, any>, accountData: NSDictionary<any, any>, options: NSDictionary<any, any>, eventType: string, sessionId: string): void;

	initWithConfiguration(configuration: any): this;

	propertiesEventTypeSessionIdIsAutoGeneratedOptions(properties: NSDictionary<string, any>, eventType: string, sessionId: string, autoGenerated: boolean, options: NSDictionary<any, any>): void;

	reset(): void;

	resetAnonymousId(): void;

	trackSOptionsEventTypeIsAutoGenerated(sessionId: string, options: NSDictionary<any, any>, eventType: string, autoGenerated: boolean): void;

	updateTimePacketSize(dispatchTimer: number, size: number): void;

	userId(): string;
}

declare class GPXAnalyticsConfiguration extends NSObject {

	static alloc(): GPXAnalyticsConfiguration; // inherited from NSObject

	static configurationWithWriteKey(writeKey: string): GPXAnalyticsConfiguration;

	static new(): GPXAnalyticsConfiguration; // inherited from NSObject

	application: SEGApplicationProtocol;

	crypto: GPXCrypto;

	enableAdvertisingTracking: boolean;

	flushAt: number;

	flushInterval: number;

	launchOptions: NSDictionary<any, any>;

	maxQueueSize: number;

	middlewares: NSArray<any>;

	payloadFilters: NSDictionary<string, string>;

	recordScreenViews: boolean;

	requestFactory: (p1: NSURL) => NSMutableURLRequest;

	shouldUseBluetooth: boolean;

	shouldUseLocationServices: boolean;

	trackApplicationLifecycleEvents: boolean;

	trackAttributionData: boolean;

	trackDeepLinks: boolean;

	trackInAppPurchases: boolean;

	trackPushNotifications: boolean;

	readonly writeKey: string;

	use(factory: any): void;
}

interface GPXCrypto extends NSObjectProtocol {

	decrypt(data: NSData): NSData;

	encrypt(data: NSData): NSData;
}
declare var GPXCrypto: {

	prototype: GPXCrypto;
};

declare class GainsightPX extends NSObject {

	static alloc(): GainsightPX; // inherited from NSObject

	static debugLogsWithEnable(enable: boolean): void;

	static disable(): void;

	static enable(): void;

	static libraryVersion(): string;

	static new(): GainsightPX; // inherited from NSObject

	static sharedInstance(): GainsightPX;

	analyticsConfigurations: PXAnalyticsConfigurations;

	globalContext: PXGlobalContext;

	uiMapperConsumer: UIMapperConsuming;

	static readonly shared: GainsightPX;

	customWithEventErrorCompletionBlock(event: string, errorCompletionBlock: (p1: string, p2: NSDictionary<string, any>, p3: NSError) => void): void;

	customWithEventPropertiesErrorCompletionBlock(event: string, properties: NSDictionary<string, any>, errorCompletionBlock: (p1: string, p2: NSDictionary<string, any>, p3: NSError) => void): void;

	enterEditingModeWithUrl(url: NSURL): void;

	exitEditingMode(): void;

	flushWithErrorCompletionBlock(errorCompletionBlock: (p1: string, p2: NSDictionary<string, any>, p3: NSError) => void): void;

	globalContextWithContext(context: PXGlobalContext): void;

	identifyWithUserAccountErrorCompletionBlock(user: PXUser, account: PXAccount, errorCompletionBlock: (p1: string, p2: NSDictionary<string, any>, p3: NSError) => void): void;

	identifyWithUserErrorCompletionBlock(user: PXUser, errorCompletionBlock: (p1: string, p2: NSDictionary<string, any>, p3: NSError) => void): void;

	identifyWithUserIdErrorCompletionBlock(userId: string, errorCompletionBlock: (p1: string, p2: NSDictionary<string, any>, p3: NSError) => void): void;

	initialiseWithConfigurationsCompletionBlock(configurations: PXAnalyticsConfigurations, completionBlock: (p1: string, p2: NSDictionary<string, any>, p3: NSError) => void): void;

	reset(): void;

	screenWithScreenPropertiesErrorCompletionBlock(screen: ScreenEvent, properties: NSDictionary<string, any>, errorCompletionBlock: (p1: string, p2: NSDictionary<string, any>, p3: NSError) => void): void;

	screenWithTitleErrorCompletionBlock(title: string, errorCompletionBlock: (p1: string, p2: NSDictionary<string, any>, p3: NSError) => void): void;

	screenWithTitlePropertiesErrorCompletionBlock(title: string, properties: NSDictionary<string, any>, errorCompletionBlock: (p1: string, p2: NSDictionary<string, any>, p3: NSError) => void): void;

	trackTapWithViewElementsPoints(viewElements: NSArray<NSDictionary<string, any>> | NSDictionary<string, any>[], points: number): void;
}

declare var GainsightPXVersionNumber: number;

declare var GainsightPXVersionString: interop.Reference<number>;

declare class PXAccount extends NSObject {

	static alloc(): PXAccount; // inherited from NSObject

	static new(): PXAccount; // inherited from NSObject

	city: string;

	continent: string;

	countryCode: string;

	countryName: string;

	customAttributes: NSDictionary<string, any>;

	id: string;

	industry: string;

	latitude: number;

	longitude: number;

	naicsCode: string;

	name?: string;

	numberOfEmployees: number;

	plan: string;

	postalCode: string;

	regionName: string;

	sfdcId: string;

	sicCode: string;

	stateCode: string;

	stateName: string;

	street: string;

	timeZone: string;

	trackedSubscriptionId: string;

	website: string;

	constructor(o: { id: string; });

	initWithId(id: string): this;
}

declare class PXAnalyticsConfigurations extends NSObject {

	static alloc(): PXAnalyticsConfigurations; // inherited from NSObject

	static new(): PXAnalyticsConfigurations; // inherited from NSObject

	apiKey: string;

	application: UIApplication;

	connection: PXConnection;

	crypto: GPXCrypto;

	currentWindow: UIWindow;

	enableCrashReporting: boolean;

	enabled: boolean;

	flushInterval: number;

	flushQueueSize: number;

	recordScreenViews: boolean;

	shouldTrackTapEvents: boolean;

	trackApplicationLifecycleEvents: boolean;

	constructor(o: { apiKey: string; });

	initWithApiKey(apiKey: string): this;
}

declare class PXConnection extends NSObject {

	static alloc(): PXConnection; // inherited from NSObject

	static new(): PXConnection; // inherited from NSObject

	readonly host: string;

	timeoutIntervalForRequest: number;

	timeoutIntervalForResource: number;

	constructor(o: { customHost: string; });

	constructor(o: { host: PXHost; });

	initWithCustomHost(customHost: string): this;

	initWithHost(host: PXHost): this;
}

declare class PXGlobalContext extends NSObject {

	static alloc(): PXGlobalContext; // inherited from NSObject

	static new(): PXGlobalContext; // inherited from NSObject

	hasKeyWithKey(key: string): boolean;

	removeKeysWithKeys(keys: NSArray<string> | string[]): void;

	setBooleanWithKeyValue(key: string, value: boolean): PXGlobalContext;

	setDateWithKeyIso(key: string, iso: string): PXGlobalContext;

	setDateWithKeyValue(key: string, value: Date): PXGlobalContext;

	setDoubleWithKeyValue(key: string, value: number): PXGlobalContext;

	setStringWithKeyValue(key: string, value: string): PXGlobalContext;
}

declare const enum PXHost {

	Us = 0,

	Eu = 1
}

declare class PXUser extends NSObject {

	static alloc(): PXUser; // inherited from NSObject

	static new(): PXUser; // inherited from NSObject

	accountId: string;

	city: string;

	continent: string;

	countryCode: string;

	countryName: string;

	customAttributes: NSDictionary<string, any>;

	email: string;

	firstName: string;

	firstVisitDate: any;

	gender: string;

	ide: string;

	lastName: string;

	latitude: number;

	longitude: number;

	organization: string;

	organizationDuns: number;

	organizationEmployees: string;

	organizationIndustry: string;

	organizationRevenue: string;

	organizationSicCode: string;

	phone: string;

	postalCode: string;

	regionName: string;

	role: string;

	score: number;

	sfdcContactId: string;

	signUpDate: any;

	stateCode: string;

	stateName: string;

	street: string;

	subscriptionId: string;

	timeZone: string;

	title: string;

	userHash: string;

	constructor(o: { userId: string; });

	initWithUserId(userId: string): this;
}

interface SEGApplicationProtocol extends NSObjectProtocol {

	delegate: UIApplicationDelegate;

	gpx_beginBackgroundTaskWithNameExpirationHandler(taskName: string, handler: () => void): number;

	gpx_endBackgroundTask(identifier: number): void;
}
declare var SEGApplicationProtocol: {

	prototype: SEGApplicationProtocol;
};

declare class ScreenEvent extends NSObject {

	static alloc(): ScreenEvent; // inherited from NSObject

	static new(): ScreenEvent; // inherited from NSObject

	screenClass: string;

	screenName: string;

	constructor(o: { screenName: string; screenClass: string; });

	initWithScreenNameScreenClass(screenName: string, screenClass: string): this;
}

declare class SessionDelegate extends NSObject implements NSURLSessionDataDelegate, NSURLSessionDelegate, NSURLSessionDownloadDelegate, NSURLSessionStreamDelegate, NSURLSessionTaskDelegate {

	static alloc(): SessionDelegate; // inherited from NSObject

	static new(): SessionDelegate; // inherited from NSObject

	readonly debugDescription: string; // inherited from NSObjectProtocol

	readonly description: string; // inherited from NSObjectProtocol

	readonly hash: number; // inherited from NSObjectProtocol

	readonly isProxy: boolean; // inherited from NSObjectProtocol

	readonly superclass: typeof NSObject; // inherited from NSObjectProtocol

	readonly  // inherited from NSObjectProtocol

	URLSessionBetterRouteDiscoveredForStreamTask(session: NSURLSession, streamTask: NSURLSessionStreamTask): void;

	URLSessionDataTaskDidBecomeDownloadTask(session: NSURLSession, dataTask: NSURLSessionDataTask, downloadTask: NSURLSessionDownloadTask): void;

	URLSessionDataTaskDidBecomeStreamTask(session: NSURLSession, dataTask: NSURLSessionDataTask, streamTask: NSURLSessionStreamTask): void;

	URLSessionDataTaskDidReceiveData(session: NSURLSession, dataTask: NSURLSessionDataTask, data: NSData): void;

	URLSessionDataTaskDidReceiveResponseCompletionHandler(session: NSURLSession, dataTask: NSURLSessionDataTask, response: NSURLResponse, completionHandler: (p1: NSURLSessionResponseDisposition) => void): void;

	URLSessionDataTaskWillCacheResponseCompletionHandler(session: NSURLSession, dataTask: NSURLSessionDataTask, proposedResponse: NSCachedURLResponse, completionHandler: (p1: NSCachedURLResponse) => void): void;

	URLSessionDidBecomeInvalidWithError(session: NSURLSession, error: NSError): void;

	URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession): void;

	URLSessionDidReceiveChallengeCompletionHandler(session: NSURLSession, challenge: NSURLAuthenticationChallenge, completionHandler: (p1: NSURLSessionAuthChallengeDisposition, p2: NSURLCredential) => void): void;

	URLSessionDownloadTaskDidFinishDownloadingToURL(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, location: NSURL): void;

	URLSessionDownloadTaskDidResumeAtOffsetExpectedTotalBytes(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, fileOffset: number, expectedTotalBytes: number): void;

	URLSessionDownloadTaskDidWriteDataTotalBytesWrittenTotalBytesExpectedToWrite(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;

	URLSessionReadClosedForStreamTask(session: NSURLSession, streamTask: NSURLSessionStreamTask): void;

	URLSessionStreamTaskDidBecomeInputStreamOutputStream(session: NSURLSession, streamTask: NSURLSessionStreamTask, inputStream: NSInputStream, outputStream: NSOutputStream): void;

	URLSessionTaskDidCompleteWithError(session: NSURLSession, task: NSURLSessionTask, error: NSError): void;

	URLSessionTaskDidFinishCollectingMetrics(session: NSURLSession, task: NSURLSessionTask, metrics: NSURLSessionTaskMetrics): void;

	URLSessionTaskDidReceiveChallengeCompletionHandler(session: NSURLSession, task: NSURLSessionTask, challenge: NSURLAuthenticationChallenge, completionHandler: (p1: NSURLSessionAuthChallengeDisposition, p2: NSURLCredential) => void): void;

	URLSessionTaskDidSendBodyDataTotalBytesSentTotalBytesExpectedToSend(session: NSURLSession, task: NSURLSessionTask, bytesSent: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;

	URLSessionTaskIsWaitingForConnectivity(session: NSURLSession, task: NSURLSessionTask): void;

	URLSessionTaskNeedNewBodyStream(session: NSURLSession, task: NSURLSessionTask, completionHandler: (p1: NSInputStream) => void): void;

	URLSessionTaskWillBeginDelayedRequestCompletionHandler(session: NSURLSession, task: NSURLSessionTask, request: NSURLRequest, completionHandler: (p1: NSURLSessionDelayedRequestDisposition, p2: NSURLRequest) => void): void;

	URLSessionTaskWillPerformHTTPRedirectionNewRequestCompletionHandler(session: NSURLSession, task: NSURLSessionTask, response: NSHTTPURLResponse, request: NSURLRequest, completionHandler: (p1: NSURLRequest) => void): void;

	URLSessionWriteClosedForStreamTask(session: NSURLSession, streamTask: NSURLSessionStreamTask): void;

	class(): typeof NSObject;

	conformsToProtocol(aProtocol: any /* Protocol */): boolean;

	isEqual(object: any): boolean;

	isKindOfClass(aClass: typeof NSObject): boolean;

	isMemberOfClass(aClass: typeof NSObject): boolean;

	performSelector(aSelector: string): any;

	performSelectorWithObject(aSelector: string, object: any): any;

	performSelectorWithObjectWithObject(aSelector: string, object1: any, object2: any): any;

	respondsToSelector(aSelector: string): boolean;

	retainCount(): number;

	self(): this;
}

declare class TaskDelegate extends NSObject {

	static alloc(): TaskDelegate; // inherited from NSObject

	static new(): TaskDelegate; // inherited from NSObject
}

interface TreeBuilding {

	build(): NSDictionary<string, any>;
}
declare var TreeBuilding: {

	prototype: TreeBuilding;
};

interface UIMapperConsuming {

	isCrossPlatform: boolean;

	createDOMStructureWithCompletion(completion: (p1: TreeBuilding) => void): void;

	getFilterClass(): string;

	getViewAtPositionWithScreenPositionCompletion(screenPosition: CGPoint, completion: (p1: TreeBuilding) => void): void;

	getViewPositionWithBuilderCompletion(builder: TreeBuilding, completion: (p1: NSArray<NSValue>) => void): void;
}
declare var UIMapperConsuming: {

	prototype: UIMapperConsuming;
};
